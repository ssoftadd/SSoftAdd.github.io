# RoundishPlugin
# Initial code generated by Softimage SDK Wizard
# Executed Sat Apr 8 11:06:06 UTC+0500 2017 by Shekn
#
# Tip: To add a command to this plug-in, right-click in the
# script editor and choose Tools > Add Command.
import win32com.client
from win32com.client import constants
from math import sqrt
from math import sin

null = None
false = 0
true = 1


def XSILoadPlugin(in_reg):
    in_reg.Author = "Shekn"
    in_reg.Name = "RoundishPlugin"
    in_reg.Major = 1
    in_reg.Minor = 0

    in_reg.RegisterCommand("Roundish", "Roundish")
    in_reg.RegisterMenu(constants.siMenuTbModelModifyComponentID, 'Roundish_Menu', False, False)
    # RegistrationInsertionPoint - do not remove this line

    return true


def XSIUnloadPlugin(in_reg):
    strPluginName = in_reg.Name
    Application.LogMessage(str(strPluginName) + str(" has been unloaded."), constants.siVerbose)
    return true


def Roundish_Menu_Init(ctxt):
    oMenu = ctxt.Source
    oMenu.AddCommandItem('Roundish', 'Roundish')
    return True


def Roundish_Init(in_ctxt):
    oCmd = in_ctxt.Source
    oCmd.Description = ""
    oCmd.ReturnValue = true

    return true


def IsArrayElement(value, array):  # return index of value in array
    tempreturn = -1
    i = 0
    for val in array:
        if val == value:
            tempreturn = i
        i = i+1
    return tempreturn


def strVector(vec):
    return '(' + str(vec.X) + ', ' + str(vec.Y) + ', ' + str(vec.Z) + ') '


def GetDistance(pos1, pos2):  # arguments are Vector3
    return sqrt((pos1.X - pos2.X) * (pos1.X - pos2.X) + (pos1.Y - pos2.Y) * (pos1.Y - pos2.Y) + (pos1.Z - pos2.Z) * (pos1.Z - pos2.Z))


def GetVector(p1, p2):  # from two positions to one vector p2-p1
    return XSIMath.CreateVector3(p2.X - p1.X, p2.Y - p1.Y, p2.Z - p1.Z)


def GetVectorLength(vec):
    return vec.Length


def AllignToPolyMesh(targetPos, obj):
    newPoses = []
    objTrans = obj.Kinematics.Global.Transform
    objGeom = obj.ActivePrimitive.Geometry
    objGeom.SetupClosestLocationQueries(constants.siClosestSurface, objTrans)
    for pos in targetPos:
        location = objGeom.GetClosestLocations(((pos.X,), (pos.Y,), (pos.Z,)))
        position = objGeom.EvaluatePositions(location)
        newPos = XSIMath.CreateVector3(position[0][0], position[1][0], position[2][0])
        newPoses = newPoses + [newPos]
    return newPoses


def FromVector3ArrayToTuple(targetPos, vertexCol, obj):
    newPositions = ()
    newX = []
    newY = []
    newZ = []
    i = 0
    for point in obj.ActivePrimitive.Geometry.Points:
        index = IsArrayElement(point.Index, vertexCol)
        if index == -1:
            newX = newX + [point.Position.X]
            newY = newY + [point.Position.Y]
            newZ = newZ + [point.Position.Z]
        else:
            newX = newX + [targetPos[i].X]
            newY = newY + [targetPos[i].Y]
            newZ = newZ + [targetPos[i].Z]
            i = i+1
    newPositions = (tuple(newX), tuple(newY), tuple(newZ))
    return newPositions


def AllignToCircle(beginPoses, adjArray, arcLength, center, radius):
    endPoses = []
    i = 0
    for pos in beginPoses:
        resultShift = XSIMath.CreateVector3()
        for adjIndex in adjArray[i]:
            sourcePos = beginPoses[adjIndex]
            toVector = GetVector(pos, sourcePos)
            modulo = toVector.Length()
            shiftVec = XSIMath.CreateVector3(0, 0, 0)
            shiftVec.Scale((modulo - arcLength)*0.01, toVector)
            resultShift.AddInPlace(shiftVec)
        i = i+1
        endPoses = endPoses + [XSIMath.CreateVector3(pos.X + resultShift.X, pos.Y + resultShift.Y, pos.Z + resultShift.Z)]
    return endPoses


def GetAdjacentArray(vertexCol, objGeom):  # return array per index. This array contains indexes in vertexCol
    adjArray = []
    for index in vertexCol:
        # for each vertex find all adjacent in this set
        oneVertexArray = []
        point = objGeom.Points(index)
        neighb = point.NeighborVertices()
        for n in neighb:
            tempIndex = IsArrayElement(n.Index, vertexCol)
            if tempIndex != -1:
                oneVertexArray = oneVertexArray + [tempIndex]
        adjArray = adjArray + [oneVertexArray]
    return adjArray


def GetCenter(vertexPositions):
    # Find center of points
    centerX = 0
    centerY = 0
    centerZ = 0
    for vertexPos in vertexPositions:
        centerX = centerX + vertexPos.X
        centerY = centerY + vertexPos.Y
        centerZ = centerZ + vertexPos.Z
    centerX = centerX / len(vertexPositions)
    centerY = centerY / len(vertexPositions)
    centerZ = centerZ / len(vertexPositions)
    return XSIMath.CreateVector3(centerX, centerY, centerZ)


def GetVertexSelection(sel):
    obj = sel.Subcomponent.Parent3DObject
    objGeom = obj.ActivePrimitive.Geometry
    vertexCol = sel.SubElements
    # construct adjacent array
    adjArray = GetAdjacentArray(vertexCol, objGeom)  # these are indexes in vertexCol
    vertexPositions = []
    for pIndex in vertexCol:
        vertexPosition = XSIMath.CreateVector3(objGeom.Points.PositionArray[0][pIndex], objGeom.Points.PositionArray[1][pIndex], objGeom.Points.PositionArray[2][pIndex],)
        vertexPositions = vertexPositions + [vertexPosition]
    center = GetCenter(vertexPositions)
    targetPos = []
    for vP in vertexPositions:
        targetPos = targetPos + [vP]
    for j in range(5):  # repeat some iterations
        distances = []
        for vertexPos in targetPos:
            distances = distances + [GetDistance(vertexPos, center)]
        # get average distance
        averDist = sum(distances)/len(distances)
        arcLength = 2 * averDist * sin(XSIMath.PI / len(distances))
        # find target position for each point
        newTP = []
        for vertexPos in targetPos:
            v = GetVector(center, vertexPos)
            e = XSIMath.CreateVector3(v.X, v.Y, v.Z)
            e.NormalizeInPlace()
            e.ScaleAddInPlace(averDist, center)
            newTP = newTP + [e]
        targetPos = AllignToPolyMesh(newTP, obj)
        # next we should move vertices around circle in equal distance
        for i in range(20):
            targetPos = AllignToCircle(targetPos, adjArray, arcLength, center, averDist)
            targetPos = AllignToPolyMesh(targetPos, obj)
    # now move vertices to new positions
    objGeom.Points.PositionArray = FromVector3ArrayToTuple(targetPos, vertexCol, obj)


def Roundish_Execute():
    Application.LogMessage("Roundish_Execute called", constants.siVerbose)
    selection = Application.Selection
    if len(selection) > 0:
        recSel = selection(0)
        recSelType = recSel.Type
        if recSelType == "polySubComponent" or recSelType == "edgeSubComponent" or recSelType == "pntSubComponent":
            obj = selection(0).Subcomponent.Parent3DObject
            objName = obj.FullName
            selection.Clear()
            selection.Add(obj, 0)
            Application.FreezeModeling("", "", "")
            Application.SelectGeometryComponents(recSel)

            if selection(0).Type == 'polySubComponent':
                polySelect = selection(0)
                Application.SelectPolygonOutline("")
                Application.SelectFilter("Edge")
                Application.SelectAdjacent("", "Point", False)
                GetVertexSelection(selection(0))
                # next relax entire polygons
                Application.SelectGeometryComponents(polySelect)
                Application.SelectPolygonOutline("")
                Application.SelectFilter("Edge")
                edgeSelect = Application.Selection(0)
                Application.ApplyOp("MarkHardEdgeVertex", edgeSelect, 3, "siPersistentOperation", "", 0)
                Application.SelectGeometryComponents(polySelect)
                Application.ApplyOp("Relax", polySelect, 3, "siPersistentOperation", "", 0)
                Application.SetValue(objName + ".polymsh.smoothop.meshpreservehardedges", True, "")
                Application.SelectGeometryComponents(edgeSelect)
                Application.SelectFilter("Edge")
                Application.ApplyOp("MarkHardEdgeVertex", edgeSelect, 3, "siPersistentOperation", "", 0)
                Application.SelectFilter("object")
                Application.SetValue(objName + ".polymsh.MarkHardEdgeVertex[1].Sharpness", False, "")
                Application.SelectGeometryComponents(polySelect)
            else:
                if selection(0).Type == 'pntSubComponent':
                    vertexSelect = selection(0)
                    GetVertexSelection(selection(0))
                    Application.SelectGeometryComponents(vertexSelect)
                    Application.SelectFilter("point")
                else:
                    if selection(0).Type == 'edgeSubComponent':
                        Application.SelectAdjacent("", "Point", False)
                        GetVertexSelection(selection(0))
        else:
            Application.LogMessage("You should select subcomponents of the polygon-mesh")
    else:
        Application.LogMessage("You should select something")
    return true
